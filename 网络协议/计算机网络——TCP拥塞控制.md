# [计算机网络——TCP拥塞控制](https://www.cnblogs.com/wkfvawl/p/12813103.html)

## 一、拥塞控制的一般原理

在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。
最坏结果：**系统崩溃**。

![img](https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501120640180-228736157.png)

### 拥塞产生的原因

网络拥塞往往是由许多因素引起的。例如：
点缓存的容量太小；
链路的容量不足；
处理机处理的速率太慢；
拥塞本身会进一步加剧拥塞；
出现拥塞的原因：
![img](https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501120739951-999496178.png)

### 增加资源能解决拥塞吗？

**不能。**这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。
网络拥塞往往是由许多因素引起的。例如：
1.增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞；
2.提高处理机处理的速率会会将瓶颈转移到其他地方；

### 拥塞控制与流量控制的区别

![img](https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501120915966-1653547862.png)

### 拥塞控制所起的作用

![img](https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501120937562-1718017624.png)

 

拥塞控制的前提：网络能够承受现有的网络负荷。
实践证明，拥塞控制是很难设计的，因为它是一个**动态问题**。
分组的丢失是网络发生拥塞的**征兆**而不是原因。
在许多情况下，甚至正是**拥塞控制本身**成为引起网络性能恶化、甚至发生死锁的原因。

### 开环控制和闭环控制

![img](https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501121023141-1621149836.png)

 

 属于闭环控制的有以下几种措施：
(1) 监测网络系统，以便检测到拥塞在何时、何处发生。
(2) 将拥塞发生的信息传送到可采取行动的地方。
(3) 调整网络系统的运行以解决出现的问题。

### 监测网络的拥塞

主要指标有：
由于缺少缓存空间而被丢弃的分组的百分数；
平均队列长度；
超时重传的分组数；
平均分组时延；
分组时延的标准差，等等。上述这些指标的上升都标志着拥塞的增长。

### 传递拥塞通知

发送通知拥塞发生的分组；
在分组中保留表示拥塞状态的字段；
周期性地发出探测分组等。

### 采取行动的时机

过于频繁，会使系统产生不稳定的振荡；
过于迟缓地采取行动又不具有任何实用价值。

### 解决拥塞的两条思路

增加网络可用资源；
减少用户对资源的需求。

## 二、TCP 的拥塞控制方法

TCP 采用**基于窗口的方法**进行拥塞控制。该方法属于闭环控制方法。
TCP发送方维持一个**拥塞窗口 cwnd (Congestion Window)**
发送端利用**拥塞窗口**根据网络的拥塞情况调整发送的数据量。
发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以**真正的发送窗口值**为：
![img](https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501121331567-74374467.png)

### 控制拥塞窗口的原则

只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。
但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。

### 拥塞的判断

![img](https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501121435352-822320514.png)

 

四种拥塞控制算法（ RFC 5681） ：
慢开始 (slow-start)
拥塞避免 (congestion avoidance)
快重传 (fast retransmit)
快恢复 (fast recovery)

### 慢开始

目的：用来确定网络的负载能力或拥塞程度。
算法的思路：由小到大逐渐增大拥塞窗口数值。

主机开发发送数据报时，如果立即将大量的数据注入到网络中，可能会出现网络的拥塞。慢启动算法就是在主机刚开始发送数据报的时候先探测一下网络的状况，如果网络状况良好，发送方每发送一次文段都能正确的接受确认报文段。那么就从小到大的增加拥塞窗口的大小，即增加发送窗口的大小。

例子：开始发送方先设置cwnd（拥塞窗口）=1,发送第一个报文段M1，接收方接收到M1后，发送方接收到接收方的确认后，把cwnd增加到2，接着发送方发送M2、M3，发送方接收到接收方发送的确认后cwnd增加到4，慢启动算法每经过一个传输轮次（认为发送方都成功接收接收方的确认），拥塞窗口cwnd就加倍。

### 拥塞避免

为了防止cwnd增加过快而导致网络拥塞，所以需要设置一个慢开始门限ssthresh状态变量,它的用法：

1. 当cwnd < ssthresh,使用慢启动算法，
2. 当cwnd > ssthresh,使用拥塞控制算法，停用慢启动算法。
3. 当cwnd = ssthresh，这两个算法都可以。

拥塞避免的思路：是让cwnd缓慢的增加而不是加倍的增长，每经历过一次往返时间就使cwnd增加1，而不是加倍，这样使cwnd缓慢的增长，比慢启动要慢的多。

无论是慢启动算法还是拥塞避免算法，只要判断网络出现拥塞，就要把慢启动开始门限(ssthresh)设置为设置为发送窗口的一半（>=2），cwnd(拥塞窗口)设置为1，然后在使用慢启动算法，这样做的目的能迅速的减少主机向网络中传输数据，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。拥塞窗口是按照线性的规律增长，比慢启动算法拥塞窗口增长块的多。

实例：
1.TCP连接进行初始化的时候，cwnd=1,ssthresh=16。
2.在慢启动算法开始时，cwnd的初始值是1，每次发送方收到一个ACK拥塞窗口就增加1，当ssthresh =cwnd时，就启动拥塞控制算法，拥塞窗口按照规律增长，
3.当cwnd=24时，网络出现超时，发送方收不到确认ACK，此时设置ssthresh=12,(二分之一cwnd),设置cwnd=1,然后开始慢启动算法，当cwnd=ssthresh=12,慢启动算法变为拥塞控制算法，cwnd按照线性的速度进行增长。

### AIMD(加法增大乘法减小)

1. 乘法减小：无论在慢启动阶段还是在拥塞控制阶段，只要网络出现超时，就是将cwnd置为1，ssthresh置为cwnd的一半，然后开始执行慢启动算法（cwnd<ssthresh）。
2. 加法增大：当网络频发出现超时情况时，ssthresh就下降的很快，为了减少注入到网络中的分组数，而加法增大是指执行拥塞避免算法后，是拥塞窗口缓慢的增大，以防止网络过早出现拥塞。
   这两个结合起来就是AIMD算法，是使用最广泛的算法。拥塞避免算法不能够完全的避免网络拥塞，通过控制拥塞窗口的大小只能使网络不易出现拥塞。

### 快重传

快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。接收方成功的接受了发送方发送来的M1、M2并且分别给发送了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5等报文段的时候，不断重复的向发送方发送M2的ACK,如果接收方一连收到三个重复的ACK,那么发送方不必等待重传计时器到期，由于发送方尽早重传未被确认的报文段。

### 快恢复

1. 当发送发连续接收到三个确认时，就执行乘法减小算法，把慢启动开始门限（ssthresh）减半，但是接下来并不执行慢开始算法。
2. 此时不执行慢启动算法，而是把cwnd设置为ssthresh的一半， 然后执行拥塞避免算法，使拥塞窗口缓慢增大

![img](https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501122139481-1636070496.png)

## 三、例题

**TCP的拥塞窗口cwnd大小与传输轮次n的关系如下****表****所示：**

| **cwnd** | 1     | 2     | 4     | 8     | 16    | 32    | **33** | **34** | **35** | **36** | **37** | **38** | **39** |
| -------- | ----- | ----- | ----- | ----- | ----- | ----- | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| **n**    | **1** | **2** | **3** | **4** | **5** | **6** | **7**  | **8**  | **9**  | **10** | **11** | **12** | **13** |

 

| **cwnd** | **40** | **41** | **42** | **21** | **22** | **23** | **24** | **25** | **26** | **1**  | **2**  | **4**  | **8**  |
| -------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| **n**    | **14** | **15** | **16** | **17** | **18** | **19** | **20** | **21** | **22** | **23** | **24** | **25** | **26** |

**![img](https://img2020.cnblogs.com/blog/1358881/202112/1358881-20211218210002131-1967562581.png)**

**指明TCP工作在慢开始阶段的时间间隔。**

[1,6]和[23,26]

**指明TCP工作在拥塞避免阶段的时间间隔。**

[6,16]和[17,22]

**在第16轮次和第22轮次之后发送方是通过收到三个重复的确认还是通过超时检测到丢失了报文段？**

在第16轮次之后发送方通过接受三个重复的确认，检测到丢失了报文段，因为题目给出，下一个轮次的拥塞窗口减半了。

在第22轮次之后发送方是通过超时检测到丢失了报文段，因为题目给出，下一个轮次的拥塞窗口下降到1了。

**在第1轮次，第18轮次和第24轮次发送时，门限ssthresh分别被设置为多大？**

在第 1 轮次发送时，门限 ssthresh 被设置为 32，因为从第 6 轮次起就进入了拥塞避免状态，拥塞窗口每个轮次加 1。

在第 18 轮次发送时，门限 ssthresh 被设置为发生拥塞时拥塞窗口 42 的一半，即 21。

在第 24 轮次发送时，门限 ssthresh 被设置为发生拥塞时拥塞窗口 26 的一半，即 13。

**在第几轮次发送出第70个报文段？**

第 1 轮次发送报文段 1。（cwnd = 1）

第 2 轮次发送报文段 2， 3。（cwnd = 2）

第 3 轮次发送报文段 4 ~ 7。（cwnd = 4）

第 4 轮次发送报文段 8 ~ 15。（cwnd = 8）

第 5 轮次发送报文段 16 ~ 31。（cwnd = 16）

第 6 轮次发送报文段 32 ~ 63。（cwnd = 32）

第 7 轮次发送报文段 64 ~ 96。（cwnd = 33）

因此第 70 报文段在第 7 轮次发送出。

**假定在第26轮次之后收到了三个重复的确认，因而检测出了报文段的丢失，那么拥塞窗口cwnd和门限ssthresh应设置为多大？**

检测出了报文段的丢失时拥塞窗口 cwnd 是 8，因此拥塞窗口 cwnd 的数值应当减半，等于 4，而门限 ssthresh 应设置为检测出报文段丢失时的拥塞窗口 8 的一半，即 4。